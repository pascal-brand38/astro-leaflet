---
// Copyright (c) Pascal Brand
// MIT License
//
// Create a leaflet map
//
// Example:
//    <Leaflet options={
//      {
//        tileLayer: 'https://{s}.google.com/vt/lyrs=y&hl=en&x={x}&y={y}&z={z}',
//        tileLayerOptions: {
//          subdomains: [ 'mt0', 'mt1', 'mt2', 'mt3' ],
//          attribution: 'Map data &copy; Google',
//    	}
//    }}/>

import type { AstroLeafletType,  } from '../index'
import { getLayerOptionsFromName } from '../layerFromName'
import "leaflet/dist/leaflet.css"

// set default properties
function setDefaultProps(props: AstroLeafletType) {
  props.options = props.options || {}
  props.options.tileLayerOptions = props.options.tileLayerOptions || {}
  props.options.center = props.options.center || [ 30, 7 ]
  props.options.zoom = props.options.zoom || 2
  if (!props.options.tileLayer) {
    props.options.tileLayer = props.options.tileLayer || "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
    props.options.tileLayerOptions.subdomains = [ 'a', 'b', 'c' ]
    props.options.tileLayerOptions.attribution = props.options.tileLayerOptions.attribution || "&copy; <a href='https://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors"
  }

  props.options.markers = props.options.markers || []
}

type Props = AstroLeafletType

const enrichedProps: AstroLeafletType = Astro.props
enrichedProps.options = enrichedProps.options || {}
if (enrichedProps.options.tileByName) {
  const layerFromName = getLayerOptionsFromName(enrichedProps.options.tileByName)
  enrichedProps.options.tileLayerOptions = enrichedProps.options.tileLayerOptions || {}
  enrichedProps.options.tileLayer = layerFromName.tileLayer
  Object.keys(layerFromName.options).forEach(key =>
    enrichedProps.options!.tileLayerOptions![key] = enrichedProps.options!.tileLayerOptions![key] || layerFromName.options[key]
  )
}
setDefaultProps(enrichedProps)

const {
  options,
  id= 'astro-leaflet-' + Math.random().toString(36).slice(2, 11),
  style: providedStyle,
  class: className,
  ...props
} = enrichedProps

// if neither style nor class is provided, set a style so that the map is displayed
const style = (!providedStyle && !className) ? 'width: 100%; height: 50vh;' : (providedStyle || '')

---

<astro-leaflet
  data-id={id}
  data-options={JSON.stringify(options)}
>
  <div id={id} style={style} class={className} {...props}>
  </div>
  <slot/>
</astro-leaflet>

<script>
  import {
    divIcon as LdivIcon,
    map as Lmap,
    marker as Lmarker,
    tileLayer as LtileLayer,
    icon as Licon,
    polyline as Lpolyline,
  } from "leaflet/dist/leaflet-src.esm"
  // } from "leaflet"
  import { getMapFromElement } from '../index'
  import type {
    AstroLeafletOptionsType,
    AstroLeafletMarkerType,
    AstroLeafletCreateIconType,
    AstroLeafletPolylineType,
    AstroLeafletTileLayerType,
  } from '../index'
  import type {
    Icon,
    DivIcon,
    Map,
    Polyline,
    TileLayer,
  } from 'leaflet'

  // fix leaflet bug: default icon not displayed in production
  // https://stackoverflow.com/questions/41144319/leaflet-marker-not-found-production-env/76454369#76454369
  const _markerDefaultIcon = Licon({
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [2, -40],
    iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.0/dist/images/marker-icon-2x.png',
    iconUrl: 'https://unpkg.com/leaflet@1.9.0/dist/images/marker-shadow.png',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.0/dist/images/marker-shadow.png',
  })

  // custom icons, by their name
  const astroLeafletIcons: { [name: string]: Icon | DivIcon } = {}

  // ***                               MANDATORY                                          ***
  // *** CustomElementCreateLeafletIcon must be declared before CustomElementAstroLeaflet ***
  // *** this ensures icons are created before the map, and so can be displayed           ***
  class CustomElementCreateLeafletIcon extends HTMLElement {
    constructor() {
      super()
      const props: AstroLeafletCreateIconType = JSON.parse(this.dataset.props!)
      astroLeafletIcons[props.name] = LdivIcon(props.options);
    }
  }
  customElements.get('create-leaflet-divicon') || customElements.define("create-leaflet-divicon", CustomElementCreateLeafletIcon);


  class CustomElementAstroLeaflet extends HTMLElement {
    /** The map, once created. Can be accessed using    getMap(id),
     * which is summarized by                           document.getElementById(id).map
     */
    map: Map | undefined    // saved map

    constructor() {
      super()
      const options: AstroLeafletOptionsType = JSON.parse(this.dataset.options!)
      const id: string = this.dataset.id!
      this.map = undefined

      this.createMap(id, options)

      // create the map only when the document is loaded,
      // so that markers are created.
      // this is in case CustomElementCreateLeafletIcon is defined after CustomElementAstroLeaflet
      // cf. https://stackoverflow.com/questions/35805252/how-to-execute-a-script-when-the-custom-element-is-upgraded
      // document.addEventListener("readystatechange", (event) => {
      //   if (document.readyState !== 'complete') {
      //     return
      //   }
      //   this.createMap(id, options)
      // })
    }

    createMap(id: string, options:AstroLeafletOptionsType) {
      let map = Lmap(id, options.mapOptions)

      map.setView(options.center!, options.zoom, options.setViewOptions)
      LtileLayer(options.tileLayer!, options.tileLayerOptions).addTo(map)

      // add markers
      if (options && options.markers) {
        // window.onload = function() {
          // create the marker on onload event, to ensure the default icon is loaded
          // this is because of the fix
          options.markers.forEach((marker:AstroLeafletMarkerType) => {
            // add the icon marker, if not the default one
            if (!marker.options) {
              marker.options = {}
            }
            marker.options.icon = _markerDefaultIcon
            if (marker.astroIconName) {
              if (astroLeafletIcons[marker.astroIconName]) {
                marker.options.icon = astroLeafletIcons[marker.astroIconName]
              }
            }

            Lmarker(marker.latlng, marker.options).addTo(map)
          })
        // }
      }

      // save the map
      console.info('astro-leaflet: map is created')
      this.map = map
    }
  }
  customElements.get('astro-leaflet') || customElements.define("astro-leaflet", CustomElementAstroLeaflet);

  class CustomElementLeafletGeneric extends HTMLElement {
    leafletElement: any | undefined
  }

  class CustomElementPolyline extends HTMLElement {
    leafletElement: Polyline | undefined

    constructor() {
      super()
      const props: AstroLeafletPolylineType = JSON.parse(this.dataset.props!)
      const map = getMapFromElement(this)
      if (map) {
        this.leafletElement = Lpolyline(props.latlngs, props.options).addTo(map!);
      }
    }
  }
  customElements.get('astro-leaflet-polyline') || customElements.define("astro-leaflet-polyline", CustomElementPolyline);


  class CustomElementTileLayer extends HTMLElement {
    leafletElement: TileLayer | undefined

    constructor() {
      super()
      const props: AstroLeafletTileLayerType = JSON.parse(this.dataset.props!)
      const map = getMapFromElement(this)
      if (map) {
        this.leafletElement = LtileLayer(props.urlTemplate, props.options).addTo(map!);
      }
    }
  }
  customElements.get('astro-leaflet-tilelayer') || customElements.define("astro-leaflet-tilelayer", CustomElementTileLayer);


  class CustomElementFitBounds extends HTMLElement {
    leafletElement: Polyline | undefined

    constructor() {
      super()
      const map = getMapFromElement(this)
      if (map) {
        // take the parent. cast to a polyline, even if not, just to check access to leafletElement
        const parent = this.parentElement as CustomElementLeafletGeneric | undefined
        if (parent && parent.leafletElement && parent.leafletElement.getBounds) {
          map.fitBounds(parent.leafletElement.getBounds())
        } else {
          console.error('astro-leaflet <FitBounds/>: no getbounds in parent')
        }
      } else {
        console.error('astro-leaflet <FitBounds/>: no map in parent')
      }
    }
  }
  customElements.get('astro-leaflet-fitbounds') || customElements.define("astro-leaflet-fitbounds", CustomElementFitBounds);

</script>
